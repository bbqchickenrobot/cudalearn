<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<# 
var types = new string[] { "int", "float", "double" }; 
#>

// Based on code from Ivan Kuckir.
// Original license notice:
/*
    Matrix class in C#
    Written by Ivan Kuckir (ivan.kuckir@gmail.com, http://blog.ivank.net)
    Faculty of Mathematics and Physics
    Charles University in Prague
    (C) 2010
    - updated on 1. 6.2014 - Trimming the string before parsing
    - updated on 14.6.2012 - parsing improved. Thanks to Andy!
    - updated on 3.10.2012 - there was a terrible bug in LU, SoLE and Inversion. Thanks to Danilo Neves Cruz for reporting that!
	
    This code is distributed under MIT licence.
		
		Permission is hereby granted, free of charge, to any person
		obtaining a copy of this software and associated documentation
		files (the "Software"), to deal in the Software without
		restriction, including without limitation the rights to use,
		copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the
		Software is furnished to do so, subject to the following
		conditions:

		The above copyright notice and this permission notice shall be
		included in all copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
		OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
		NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
		HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
		WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
		FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
		OTHER DEALINGS IN THE SOFTWARE.
*/


using System;
using System.Diagnostics.Contracts;

namespace CudaLearn
{
	internal static class MatrixHelper
	{
		
	<# foreach (var type in types ) 
	{ #>
			<# if ( type != "int") 
			{#>
								

				internal static Matrix<<#=type#>> SolveWith( Matrix<<#=type#>> A, Matrix<<#=type#>> v )
				{
					if (A.Rows != A.Columns)
						throw new InvalidOperationException("The matrix is not square!");
					if (A.Rows != v.Rows)
						throw new InvalidOperationException("Wrong number of results in solution vector!");
				
					var decomposition = A.Decomposition;
					var pi = decomposition.Permutation;

					Matrix<<#=type#>> b = new Matrix<<#=type#>>(A.Rows, 1);
					for (int i = 0; i < A.Rows; i++) 
						b[i, 0] = v[pi[i], 0];   // switch two items in "v" due to permutation matrix

					Matrix<<#=type#>> z = SubsForth(decomposition.L, b);
					Matrix<<#=type#>> x = SubsBack(decomposition.U, z);

					return x;
				}

			    /// <summary>
				/// Function solves Ax = b for A as a lower triangular matrix
				/// </summary>
				private static Matrix<<#=type#>> SubsForth(Matrix<<#=type#>> A, Matrix<<#=type#>> b)          // 
				{				
					int n = A.Rows;
					Matrix<<#=type#>> x = new Matrix<<#=type#>>(n, 1);

					for (int i = 0; i < n; i++)
					{
						x[i, 0] = b[i, 0];
						for (int j = 0; j < i; j++) 
							x[i, 0] -= A[i, j] * x[j, 0];
						x[i, 0] = x[i, 0] / A[i, i];
					}
					return x;
				}

				/// <summary>
				/// Function solves Ax = b for A as an upper triangular matrix
				/// </summary>
				private static Matrix<<#=type#>> SubsBack(Matrix<<#=type#>> A, Matrix<<#=type#>> b)
				{
					int n = A.Rows;
					
					Matrix<<#=type#>> x = new Matrix<<#=type#>>(n, 1);
					for (int i = n - 1; i > -1; i--)
					{
						x[i, 0] = b[i, 0];
						for (int j = n - 1; j > i; j--) 
							x[i, 0] -= A[i, j] * x[j, 0];
						x[i, 0] = x[i, 0] / A[i, i];
					}
					return x;
				}


				internal static Matrix<<#=type#>> Invert ( Matrix<<#=type#>> m )
				{					
					Matrix<<#=type#>> inv = new Matrix<<#=type#>>(m.Rows, m.Columns);

					for (int i = 0; i < m.Rows; i++)
					{
						Matrix<<#=type#>> Ei = Matrix<<#=type#>>.Zeroes(m.Rows, 1);
						Ei[i, 0] = 1;
						Matrix<<#=type#>> col = SolveWith(m, Ei);
						inv.SetColumn(col, i);
					}
					return inv;				
				}

				internal static <#=type#> Determinant ( Matrix<<#=type#>> m )
				{
					var decomposition = m.Decomposition;
				
					var u = decomposition.U;
					var det = decomposition.DeterminantOfP;

					for (int i = 0; i < m.Rows; i++) 
						det *= u[i, i];
					return det;
				}

				internal static Decomposition<<#=type#>> LUDecomposition( Matrix<<#=type#>> m )
				{				
					var L = Matrix<<#=type#>>.Identity(m.Rows, m.Columns);
					var U = m.Clone();

					var pi = new int[m.Rows];
					for (int i = 0; i < m.Rows; i++) 
						pi[i] = i;

					<#=type#> detOfP = Matrix<<#=type#>>.One;
					<#=type#> p = 0;
					<#=type#> pom2;
					int k0 = 0;
					int pom1 = 0;

					for (int k = 0; k < m.Columns - 1; k++)
					{
						p = 0;
						for (int i = k; i < m.Rows; i++)      // find the row with the biggest pivot
						{
							if (Math.Abs(U[i, k]) > p)
							{
								p = Math.Abs(U[i, k]);
								k0 = i;
							}
						}

						if (p == 0) // samé nuly ve sloupci
							throw new InvalidOperationException("The matrix is singular!");

						pom1 = pi[k]; pi[k] = pi[k0]; pi[k0] = pom1;    // switch two rows in permutation matrix

						for (int i = 0; i < k; i++)
						{
							pom2 = L[k, i]; L[k, i] = L[k0, i]; L[k0, i] = pom2;
						}

						if (k != k0) 
							detOfP *= -1;

						for (int i = 0; i < m.Columns; i++)                  // Switch rows in U
						{
							pom2 = U[k, i]; U[k, i] = U[k0, i]; U[k0, i] = pom2;
						}

						for (int i = k + 1; i < m.Rows; i++)
						{
							L[i, k] = U[i, k] / U[k, k];
							for (int j = k; j < m.Columns; j++)
								U[i, j] = U[i, j] - L[i, k] * U[k, j];
						}
					}	
				
					return new Decomposition<<#=type#>> ( L, U, pi, detOfP );		
				}						
			<#}#>


			internal static bool Equals(Matrix<<#=type#>> m1, Matrix<<#=type#>> m2, <#=type#> epsilon)
			{
				for (int i = 0; i < m1.Rows; i++)
				{
					for (int j = 0; j < m1.Columns; j++)
					{
						<#=type#> value = m1[i, j] - m2[i, j];
						value = value < 0 ? -value : value;

						if (value > epsilon)
							return false;
					}
				}	
				
				return true;		
			}

			internal static Matrix<<#=type#>> Negative(Matrix<<#=type#>> m)
			{
				Matrix<<#=type#>> r = new Matrix<<#=type#>>(m.Rows, m.Columns);
				for (int i = 0; i < m.Rows; i++)
					for (int j = 0; j < m.Columns; j++)
						r[i, j] = -m[i, j];
				return r;
			}

			internal static Matrix<<#=type#>> Add(Matrix<<#=type#>> n, Matrix<<#=type#>> m)       
			{
				Matrix<<#=type#>> r = new Matrix<<#=type#>>(m.Rows, m.Columns);
				for (int i = 0; i < m.Rows; i++)
					for (int j = 0; j < m.Columns; j++)
						r[i, j] = m[i, j] + n[i, j];
				return r;
			}

			internal static Matrix<<#=type#>> Substract(Matrix<<#=type#>> n, Matrix<<#=type#>> m)       
			{
				Matrix<<#=type#>> r = new Matrix<<#=type#>>(m.Rows, m.Columns);
				for (int i = 0; i < m.Rows; i++)
					for (int j = 0; j < m.Columns; j++)
						r[i, j] = m[i, j] - n[i, j];
				return r;
			}

			internal static Matrix<<#=type#>> Add(<#=type#> n, Matrix<<#=type#>> m)       
			{
				Matrix<<#=type#>> r = new Matrix<<#=type#>>(m.Rows, m.Columns);
				for (int i = 0; i < m.Rows; i++)
					for (int j = 0; j < m.Columns; j++)
						r[i, j] = m[i, j] + n;
				return r;
			}

			internal static Matrix<<#=type#>> Substract(<#=type#> n, Matrix<<#=type#>> m)       
			{
				Matrix<<#=type#>> r = new Matrix<<#=type#>>(m.Rows, m.Columns);
				for (int i = 0; i < m.Rows; i++)
					for (int j = 0; j < m.Columns; j++)
						r[i, j] = m[i, j] - n;
				return r;
			}


			internal static Matrix<<#=type#>> Multiply(<#=type#> n, Matrix<<#=type#>> m)                          // Multiplication by constant n
			{
				Matrix<<#=type#>> r = new Matrix<<#=type#>>(m.Rows, m.Columns);
				for (int i = 0; i < m.Rows; i++)
					for (int j = 0; j < m.Columns; j++)
						r[i, j] = m[i, j] * n;
				return r;
			}

			internal static Matrix<<#=type#>> StrassenMultiply(Matrix<<#=type#>> A, Matrix<<#=type#>> B)                // Smart matrix multiplication
			{
				Contract.Requires<ArgumentException>(A.Columns == B.Rows, "Wrong dimension of matrix!");

				Matrix<<#=type#>> R;

				int msize = Math.Max(Math.Max(A.Rows, A.Columns), Math.Max(B.Rows, B.Columns));
				if (msize < 32)
				{
					R = Matrix<<#=type#>>.Zeroes(A.Rows, B.Columns);
					for (int i = 0; i < R.Rows; i++)
						for (int j = 0; j < R.Columns; j++)
							for (int k = 0; k < A.Columns; k++)
								R[i, j] += A[i, k] * B[k, j];
					return R;
				}

				int size = 1; int n = 0;
				while (msize > size) { size *= 2; n++; };
				int h = size / 2;


				Matrix<<#=type#>>[,] mField = new Matrix<<#=type#>>[n, 9];

				/*
				 *  8x8, 8x8, 8x8, ...
				 *  4x4, 4x4, 4x4, ...
				 *  2x2, 2x2, 2x2, ...
				 *  . . .
				 */

				int z;
				for (int i = 0; i < n - 4; i++)          // rows
				{
					z = (int)Math.Pow(2, n - i - 1);
					for (int j = 0; j < 9; j++) 
						mField[i, j] = new Matrix<<#=type#>>(z, z);
				}

				SafeAplusBintoC(A, 0, 0, A, h, h, mField[0, 0], h);
				SafeAplusBintoC(B, 0, 0, B, h, h, mField[0, 1], h);
				StrassenMultiplyRun(mField[0, 0], mField[0, 1], mField[0, 1 + 1], 1, mField); // (A11 + A22) * (B11 + B22);

				SafeAplusBintoC(A, 0, h, A, h, h, mField[0, 0], h);
				SafeACopytoC(B, 0, 0, mField[0, 1], h);
				StrassenMultiplyRun(mField[0, 0], mField[0, 1], mField[0, 1 + 2], 1, mField); // (A21 + A22) * B11;

				SafeACopytoC(A, 0, 0, mField[0, 0], h);
				SafeAminusBintoC(B, h, 0, B, h, h, mField[0, 1], h);
				StrassenMultiplyRun(mField[0, 0], mField[0, 1], mField[0, 1 + 3], 1, mField); //A11 * (B12 - B22);

				SafeACopytoC(A, h, h, mField[0, 0], h);
				SafeAminusBintoC(B, 0, h, B, 0, 0, mField[0, 1], h);
				StrassenMultiplyRun(mField[0, 0], mField[0, 1], mField[0, 1 + 4], 1, mField); //A22 * (B21 - B11);

				SafeAplusBintoC(A, 0, 0, A, h, 0, mField[0, 0], h);
				SafeACopytoC(B, h, h, mField[0, 1], h);
				StrassenMultiplyRun(mField[0, 0], mField[0, 1], mField[0, 1 + 5], 1, mField); //(A11 + A12) * B22;

				SafeAminusBintoC(A, 0, h, A, 0, 0, mField[0, 0], h);
				SafeAplusBintoC(B, 0, 0, B, h, 0, mField[0, 1], h);
				StrassenMultiplyRun(mField[0, 0], mField[0, 1], mField[0, 1 + 6], 1, mField); //(A21 - A11) * (B11 + B12);

				SafeAminusBintoC(A, h, 0, A, h, h, mField[0, 0], h);
				SafeAplusBintoC(B, 0, h, B, h, h, mField[0, 1], h);
				StrassenMultiplyRun(mField[0, 0], mField[0, 1], mField[0, 1 + 7], 1, mField); // (A12 - A22) * (B21 + B22);

				R = new Matrix<<#=type#>>(A.Rows, B.Columns);                  // result

				/// C11
				for (int i = 0; i < Math.Min(h, R.Rows); i++)          // rows
					for (int j = 0; j < Math.Min(h, R.Columns); j++)     // cols
						R[i, j] = mField[0, 1 + 1][i, j] + mField[0, 1 + 4][i, j] - mField[0, 1 + 5][i, j] + mField[0, 1 + 7][i, j];

				/// C12
				for (int i = 0; i < Math.Min(h, R.Rows); i++)          // rows
					for (int j = h; j < Math.Min(2 * h, R.Columns); j++)     // cols
						R[i, j] = mField[0, 1 + 3][i, j - h] + mField[0, 1 + 5][i, j - h];

				/// C21
				for (int i = h; i < Math.Min(2 * h, R.Rows); i++)          // rows
					for (int j = 0; j < Math.Min(h, R.Columns); j++)     // cols
						R[i, j] = mField[0, 1 + 2][i - h, j] + mField[0, 1 + 4][i - h, j];

				/// C22
				for (int i = h; i < Math.Min(2 * h, R.Rows); i++)          // rows
					for (int j = h; j < Math.Min(2 * h, R.Columns); j++)     // cols
						R[i, j] = mField[0, 1 + 1][i - h, j - h] - mField[0, 1 + 2][i - h, j - h] + mField[0, 1 + 3][i - h, j - h] + mField[0, 1 + 6][i - h, j - h];

				return R;
			}

			// function for square matrix 2^N x 2^N

			private static void StrassenMultiplyRun(Matrix<<#=type#>> A, Matrix<<#=type#>> B, Matrix<<#=type#>> C, int l, Matrix<<#=type#>>[,] f)    // A * B into C, level of recursion, matrix field
			{
				int size = A.Rows;
				int h = size / 2;

				if (size < 32)
				{
					for (int i = 0; i < C.Rows; i++)
						for (int j = 0; j < C.Columns; j++)
						{
							C[i, j] = 0;
							for (int k = 0; k < A.Columns; k++) C[i, j] += A[i, k] * B[k, j];
						}
					return;
				}

				AplusBintoC(A, 0, 0, A, h, h, f[l, 0], h);
				AplusBintoC(B, 0, 0, B, h, h, f[l, 1], h);
				StrassenMultiplyRun(f[l, 0], f[l, 1], f[l, 1 + 1], l + 1, f); // (A11 + A22) * (B11 + B22);

				AplusBintoC(A, 0, h, A, h, h, f[l, 0], h);
				ACopytoC(B, 0, 0, f[l, 1], h);
				StrassenMultiplyRun(f[l, 0], f[l, 1], f[l, 1 + 2], l + 1, f); // (A21 + A22) * B11;

				ACopytoC(A, 0, 0, f[l, 0], h);
				AminusBintoC(B, h, 0, B, h, h, f[l, 1], h);
				StrassenMultiplyRun(f[l, 0], f[l, 1], f[l, 1 + 3], l + 1, f); //A11 * (B12 - B22);

				ACopytoC(A, h, h, f[l, 0], h);
				AminusBintoC(B, 0, h, B, 0, 0, f[l, 1], h);
				StrassenMultiplyRun(f[l, 0], f[l, 1], f[l, 1 + 4], l + 1, f); //A22 * (B21 - B11);

				AplusBintoC(A, 0, 0, A, h, 0, f[l, 0], h);
				ACopytoC(B, h, h, f[l, 1], h);
				StrassenMultiplyRun(f[l, 0], f[l, 1], f[l, 1 + 5], l + 1, f); //(A11 + A12) * B22;

				AminusBintoC(A, 0, h, A, 0, 0, f[l, 0], h);
				AplusBintoC(B, 0, 0, B, h, 0, f[l, 1], h);
				StrassenMultiplyRun(f[l, 0], f[l, 1], f[l, 1 + 6], l + 1, f); //(A21 - A11) * (B11 + B12);

				AminusBintoC(A, h, 0, A, h, h, f[l, 0], h);
				AplusBintoC(B, 0, h, B, h, h, f[l, 1], h);
				StrassenMultiplyRun(f[l, 0], f[l, 1], f[l, 1 + 7], l + 1, f); // (A12 - A22) * (B21 + B22);

				/// C11
				for (int i = 0; i < h; i++)          // rows
					for (int j = 0; j < h; j++)     // cols
						C[i, j] = f[l, 1 + 1][i, j] + f[l, 1 + 4][i, j] - f[l, 1 + 5][i, j] + f[l, 1 + 7][i, j];

				/// C12
				for (int i = 0; i < h; i++)          // rows
					for (int j = h; j < size; j++)     // cols
						C[i, j] = f[l, 1 + 3][i, j - h] + f[l, 1 + 5][i, j - h];

				/// C21
				for (int i = h; i < size; i++)          // rows
					for (int j = 0; j < h; j++)     // cols
						C[i, j] = f[l, 1 + 2][i - h, j] + f[l, 1 + 4][i - h, j];

				/// C22
				for (int i = h; i < size; i++)          // rows
					for (int j = h; j < size; j++)     // cols
						C[i, j] = f[l, 1 + 1][i - h, j - h] - f[l, 1 + 2][i - h, j - h] + f[l, 1 + 3][i - h, j - h] + f[l, 1 + 6][i - h, j - h];
			}

			private static void SafeAplusBintoC(Matrix<<#=type#>> A, int xa, int ya, Matrix<<#=type#>> B, int xb, int yb, Matrix<<#=type#>> C, int size)
			{
				for (int i = 0; i < size; i++)          // rows
					for (int j = 0; j < size; j++)     // cols
					{
						C[i, j] = 0;
						if (xa + j < A.Columns && ya + i < A.Rows) 
							C[i, j] += A[ya + i, xa + j];
						if (xb + j < B.Columns && yb + i < B.Rows) 
							C[i, j] += B[yb + i, xb + j];
					}
			}

			private static void SafeAminusBintoC(Matrix<<#=type#>> A, int xa, int ya, Matrix<<#=type#>> B, int xb, int yb, Matrix<<#=type#>> C, int size)
			{
				for (int i = 0; i < size; i++)          // rows
					for (int j = 0; j < size; j++)     // cols
					{
						C[i, j] = 0;
						if (xa + j < A.Columns && ya + i < A.Rows) 
							C[i, j] += A[ya + i, xa + j];
						if (xb + j < B.Columns && yb + i < B.Rows)
							C[i, j] -= B[yb + i, xb + j];
					}
			}

			private static void SafeACopytoC(Matrix<<#=type#>> A, int xa, int ya, Matrix<<#=type#>> C, int size)
			{
				for (int i = 0; i < size; i++)          // rows
					for (int j = 0; j < size; j++)     // cols
					{
						C[i, j] = 0;
						if (xa + j < A.Columns && ya + i < A.Rows) 
							C[i, j] += A[ya + i, xa + j];
					}
			}

			private static void AplusBintoC(Matrix<<#=type#>> A, int xa, int ya, Matrix<<#=type#>> B, int xb, int yb, Matrix<<#=type#>> C, int size)
			{
				for (int i = 0; i < size; i++)          // rows
					for (int j = 0; j < size; j++) 
						C[i, j] = A[ya + i, xa + j] + B[yb + i, xb + j];
			}

			private static void AminusBintoC(Matrix<<#=type#>> A, int xa, int ya, Matrix<<#=type#>> B, int xb, int yb, Matrix<<#=type#>> C, int size)
			{
				for (int i = 0; i < size; i++)          // rows
					for (int j = 0; j < size; j++) 
						C[i, j] = A[ya + i, xa + j] - B[yb + i, xb + j];
			}

			private static void ACopytoC(Matrix<<#=type#>> A, int xa, int ya, Matrix<<#=type#>> C, int size)
			{
				for (int i = 0; i < size; i++)          // rows
					for (int j = 0; j < size; j++) 
						C[i, j] = A[ya + i, xa + j];
			}
	<#}
	#>

	}

}